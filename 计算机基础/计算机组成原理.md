# 计算机组成原理

### 计算机组成

#### CPU

冯诺依曼模型中 CPU 负责控制和计算。为了方便计算较大的数值，CPU 每次可以计算多个字节的数据。

- 如果 CPU 每次可以计算 4 个 byte，那么我们称作 32 位 CPU；
- 如果 CPU 每次可以计算 8 个 byte，那么我们称作 64 位 CPU。

这里的 32 和 64，称作 CPU 的位宽。

为什么 CPU 要这样设计呢？ 因为一个 byte 最大的表示范围就是 0~255。比如要计算 20000*50，就超出了byte 最大的表示范围了。因此，CPU 需要支持多个 byte 一起计算。当然，CPU 位数越大，可以计算的数值就越大。但是在现实生活中不一定需要计算这么大的数值。比如说 32 位 CPU 能计算的最大整数是 4294967295，这已经非常大了。

**控制单元和逻辑运算单元**

CPU 中有一个控制单元专门负责控制 CPU 工作；还有逻辑运算单元专门负责计算。具体的工作原理我们在指令部分给大家分析。

**寄存器**

CPU 要进行计算，比如最简单的加和两个数字时，因为 CPU 离内存太远，所以需要一种离自己近的存储来存储将要被计算的数字。这种存储就是寄存器。寄存器就在 CPU 里，控制单元和逻辑运算单元非常近，因此速度很快。

- 寄存器中有一部分是可供用户编程用的，比如用来存加和指令的两个参数，是**通用寄存器**。
- 还有一部分寄存器有特殊的用途，叫作**特殊寄存器**。比如程序指针，就是一个特殊寄存器。它存储了 CPU 要执行的下一条指令所在的内存地址。注意，程序指针不是存储了下一条要执行的指令，此时指令还在内存中，程序指针只是存储了下一条指令的地址。
- 下一条要执行的指令，会从内存读入到另一个特殊的寄存器中，这个寄存器叫作**指令寄存器**。指令被执行完成之前，指令都存储在这里。

#### 总线

CPU 和内存以及其他设备之间，也需要通信，因此我们用一种特殊的设备进行控制，就是总线。总线分成 3 种：

- 一种是**地址总线**，专门用来指定 CPU 将要操作的内存地址。
- 还有一种是**数据总线**，用来读写内存中的数据。

当 CPU 需要读写内存的时候，**先要通过地址总线来指定内存地址，再通过数据总线来传输数据**。

- 最后一种总线叫作**控制总线**，**用来发送和接收关键信号**，比如后面我们会学到的中断信号，还有设备复位、就绪等信号，都是通过控制总线传输。同样的，CPU 需要对这些信号进行响应，这也需要控制总线。

#### 输入、输出设备

输入设备向计算机输入数据，计算机经过计算，将结果通过输出设备向外界传达。如果输入设备、输出设备想要和 CPU 进行交互，比如说用户按键需要 CPU 响应，这时候就需要用到控制总线。

到这里，相信你已经对冯诺依曼模型的构造有了一定的了解。这里我再强调几个问题：

##### 1. 线路位宽问题

第一个问题是，你可能会好奇数据如何通过线路传递。其实是通过操作电压，低电压是 0，高电压是 1。

如果只有一条线路，每次只能传递 1 个信号，因为你必须在 0,1 中选一个。比如你构造高高低低这样的信号，其实就是 1100，相当于你传了一个数字 10 过去。大家注意，这种传递是相当慢的，因为你需要传递 4 次。

这种一个 bit 一个 bit 发送的方式，我们叫作串行。如果希望每次多传一些数据，就需要增加线路，也就是需要并行。

如果只有 **1 条地址总线，那每次只能表示 0-1 两种情况，所以只能操作 2 个内存地址**；如果有 10 条地址总线，一次就可以表示 210 种情况，也就是可以操作 1024 个内存地址；如果你希望操作 4G 的内存，那么就需要 32 条线，因为 2^32 是 4G。

到这里，你可能会问，那我串行发送行不行？当然也不是不行，只是速度会很慢，因为每多增加一条线路速度就会翻倍。

##### 2. 64 位和 32 位的计算

第二个问题是，CPU 的位宽会对计算造成什么影响？

我们来看一个具体场景：要用 32 位宽的 CPU，加和两个 64 位的数字。

32 位宽的 CPU 控制 40 位宽的地址总线、数据总线工作会非常麻烦，需要双方制定协议。 因此通常 32 位宽 CPU 最多操作 32 位宽的地址总线和数据总线。

因此必须把两个 64 位数字拆成 2 个 32 位数字来计算，这样就需要一个算法，比如用像小时候做加法竖式一样，先加和两个低位的 32 位数字，算出进位，然后加和两个高位的 32 位数字，最后再加上进位。

而 64 位的 CPU 就可以一次读入 64 位的数字，同时 64 位的 CPU 内部的逻辑计算单元，也支持 64 位的数字进行计算。但是你千万不要仅仅因为位宽的区别，就认为 64 位 CPU 性能比 32 位高很多。

要知道大部分应用不需要计算超过 32 位的数字，比如你做一个电商网站，用户的金额通常是 10 万以下的，而 32 位有符号整数，最大可以到 20 亿。所以这样的计算在 32 位还是 64 位中没有什么区别。

还有一点要注意，**32 位宽的 CPU 没办法控制超过 32 位的地址总线**、数据总线工作。比如说你有一条 40 位的地址总线（其实就是 40 条线），32 位的 CPU 没有办法一次给 40 个信号，因为它最多只有 32 位的寄存器。因此 **32 位宽的 CPU 最多操作 2^32 个内存地址，也就是 4G 内存地址**。

### 程序的执行过程

当 CPU 执行程序的时候：

1.首先，CPU 读取 PC 指针指向的指令，将它导入指令寄存器。具体来说，完成读取指令这件事情有 3 个步骤：

**步骤 1**：CPU 的**控制单元**操作地址总线指定需要访问的内存地址（简单理解，就是把 PC 指针中的值拷贝到地址总线中）。

**步骤 2**：CPU 通知内存设备准备数据（内存设备准备好了，就通过数据总线将数据传送给 CPU）。

**步骤 3**：CPU 收到内存传来的数据后，**将这个数据存入指令寄存器**。

完成以上 3 步，CPU 成功读取了 PC 指针指向指令，存入了指令寄存器。

2.然后，CPU 分析指令寄存器中的指令，确定指令的类型和参数。 

3.如果是计算类型的指令，那么就交给逻辑运算单元计算；如果是存储类型的指令，那么由控制单元执行。 

4.PC 指针自增，并准备获取下一条指令。

> 比如**在 32 位的机器上，指令是 32 位 4 个字节，需要 4 个内存地址存储**，因此 PC 指针会自增 4。

![图片1](http://learn.lianglianglee.com/专栏/重学操作系统-完/assets/Ciqc1F9fGs2AEfeRAADnPPOm_gU294.png)

了解了程序的执行过程后，我还有一些问题想和大家一起讨论：

1. 内存虽然是一个随机存取器，但是我们通常不会把指令和数据存在一起，这是为了安全起见。具体的原因我会在模块四进程部分展开讲解，欢迎大家在本课时的留言区讨论起来，我会结合你们留言的内容做后续的课程设计。
2. 程序指针也是一个寄存器，64 位的 CPU 会提供 64 位的寄存器，这样就可以使用更多内存地址。特别要说明的是，64 位的寄存器可以寻址的范围非常大，但是也会受到地址总线条数的限制。比如和 64 位 CPU 配套工作的地址总线只有 40 条，那么可以寻址的范围就只有 1T，也就是 240。
3. 从 PC 指针读取指令、到执行、再到下一条指令，构成了一个循环，这个不断循环的过程叫作**CPU 的指令周期**，下面我们会详细讲解这个概念。

#### 详解 a = 11 + 15 的执行过程

上面我们了解了基本的程序执行过程，接下来我们来看看如果用冯诺依曼模型执行`a=11+15`是一个怎样的过程。

我们再 Review 下这个问题：程序员写的程序`a=11+15`是字符串，CPU 不能执行字符串，只能执行指令。所以这里需要用到一种特殊的程序——编译器。编译器的核心能力是翻译，它把一种程序翻译成另一种程序语言。

这里，我们需要编译器将程序员写的程序翻译成 CPU 认识的指令（指令我们认为是一种低级语言，我们平时书写的是高级语言）。你可以先跟我完整地学完操作系统，再去深入了解编译原理的内容。

下面我们来详细阐述 a=11+15 的执行过程：

1.编译器通过分析，发现 11 和 15 是数据，因此编译好的程序启动时，会在内存中开辟出一个专门的区域存这样的常数，这个专门用来存储常数的区域，就是数据段，如下图所示：

- 11 被存储到了地址 0x100；
- 15 被存储到了地址 0x104；

![1.png](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/Ciqc1F9jNVKAbRJhAADt2il2zYI826.png)

2.编译器将`a=11+15`转换成了 4 条指令，程序启动后，这些指令被导入了一个专门用来存储指令的区域，也就是正文段。如上图所示，这 4 条指令被存储到了 0x200-0x20c 的区域中：

0x200 位置的 load 指令将地址 0x100 中的数据 11 导入寄存器 R0；

0x204 位置的 load 指令将地址 0x104 中的数据 15 导入寄存器 R1；

0x208 位置的 add 指令将寄存器 R0 和 R1 中的值相加，存入寄存器 R2；

0x20c 位置的 store 指令将寄存器 R2 中的值存回数据区域中的 0x1108 位置。

3.具体执行的时候，PC 指针先指向 0x200 位置，然后依次执行这 4 条指令。

这里还有几个问题要说明一下：

1. 变量 a 实际上是内存中的一个地址，a 是给程序员的助记符。
2. 为什么 0x200 中代表加载数据到寄存器的指令是 0x8c000100，我们会在下面详细讨论。
3. 不知道细心的同学是否发现，在上面的例子中，我们每次操作 4 个地址，也就是 32 位，这是因为我们在用 32 位宽的 CPU 举例。在 32 位宽的 CPU 中，指令也是 32 位的。但是数据可以小于 32 位，比如可以加和两个 8 位的字节。
4. 关于数据段和正文段的内容，会在模块四进程和线程部分继续讲解。

#### 指令

接下来我会带你具体分析指令的执行过程。

在上面的例子中，load 指令将内存中的数据导入寄存器，我们写成了 16 进制：0x8c000100，拆分成二进制就是：

> 这里大家还是看下图，需要看一下才能明白。

![12.png](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/CgqCHl9fMJiAXO1-AABvVvPHepg435.png)

- 最左边的 6 位，叫作**操作码**，英文是 OpCode，100011 代表 load 指令；
- 中间的 4 位 0000是寄存器的编号，这里代表寄存器 R0；
- 后面的 22 位代表要读取的地址，也就是 0x100。

所以我们是把操作码、寄存器的编号、要读取的地址合并到了一个 32 位的指令中。

我们再来看一条求加法运算的 add 指令，16 进制表示是 0x08048000，换算成二进制就是：

![11.png](http://learn.lianglianglee.com/专栏/重学操作系统-完/assets/Ciqc1F9fMKGAT9ymAACIAk1pGnk727.png)

- 最左边的 6 位是指令编码，代表指令 add；
- 紧接着的 4 位 0000 代表寄存器 R0；
- 然后再接着的 4 位 0001 代表寄存器 R1；
- 再接着的 4 位 0010 代表寄存器 R2；
- 最后剩下的 14 位没有被使用。

构造指令的过程，叫作指令的编码，通常由编译器完成；解析指令的过程，叫作指令的解码，由 CPU 完成。由此可见 CPU 内部有一个循环：

1. 首先 CPU 通过 PC 指针读取对应内存地址的指令，我们将这个步骤叫作 Fetch，就是获取的意思。
2. CPU 对指令进行解码，我们将这个部分叫作 Decode。
3. CPU 执行指令，我们将这个部分叫作 Execution。
4. CPU 将结果存回寄存器或者将寄存器存入内存，我们将这个步骤叫作 Store。

![image](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/Ciqc1F9fMKiAZhMVAABIVEePzcA916.png)

上面 4 个步骤，我们叫作 CPU 的指令**周期**。CPU 的工作就是一个周期接着一个周期，周而复始。

#### 指令的类型

通过上面的例子，你会发现不同类型（不同 OpCode）的指令、参数个数、每个参数的位宽，都不一样。而参数可以是以下这三种类型：

1. 寄存器；
2. 内存地址；
3. 数值（一般是整数和浮点）。

当然，无论是寄存器、内存地址还是数值，它们都是数字。

指令从功能角度来划分，大概有以下 5 类：

1. I/O 类型的指令，比如处理和内存间数据交换的指令 store/load 等；再比如将一个内存地址的数据转移到另一个内存地址的 mov 指令。
2. 计算类型的指令，最多只能处理两个寄存器，比如加减乘除、位运算、比较大小等。
3. 跳转类型的指令，用处就是修改 PC 指针。比如编程中大家经常会遇到需要条件判断+跳转的逻辑，比如 if-else，swtich-case、函数调用等。
4. 信号类型的指令，比如发送中断的指令 trap。
5. 闲置 CPU 的指令 nop，一般 CPU 都有这样一条指令，执行后 CPU 会空转一个周期。

指令还有一个分法，就是寻址模式，比如同样是求和指令，可能会有 2 个版本：

1. 将两个寄存器的值相加的 add 指令。
2. 将一个寄存器和一个整数相加的 addi 指令。

另外，同样是加载内存中的数据到寄存器的 load 指令也有不同的寻址模式：

1. 比如直接加载一个内存地址中的数据到寄存器的指令`la`，叫作直接寻址。
2. 直接将一个数值导入寄存器的指令`li`，叫作寄存器寻址。
3. 将一个寄存器中的数值作为地址，然后再去加载这个地址中数据的指令`lw`，叫作间接寻址。

**因此寻址模式是从指令如何获取数据的角度，对指令的一种分类，目的是给编写指令的人更多选择**。

了解了指令的类型后，我再强调几个细节问题：

1. 关于寻址模式和所有的指令，只要你不是嵌入式开发人员，就不需要记忆，理解即可。
2. 不同 CPU 的指令和寄存器名称都不一样，因此这些名称也不需要你记忆。
3. 有几个寄存器在所有 CPU 里名字都一样，比如 PC 指针、指令寄存器等。

#### 指令的执行速度

之前我们提到过 CPU 是用石英晶体产生的脉冲转化为时钟信号驱动的，每一次时钟信号高低电平的转换就是一个周期，我们称为**时钟周期**。CPU 的主频，说的就是时钟信号的频率。比如一个 1GHz 的 CPU，说的是时钟信号的频率是 1G。

到这里你可能会有疑问：是不是每个时钟周期都可以执行一条指令？其实，不是的，多数指令不能在一个时钟周期完成，通常需要 2 个、4 个、6 个时钟周期。